import taichi as ti
import taichi.math as tm
import numpy as np
from util import *

from pywavefront import Wavefront
from scene import Scene, Init
import pyvista as pv
import tetgen

pv.set_plot_theme('document')

box = pv.Box([-0.5, 0.5, -0.5, 0.5, -0.5, 0.5]
             ).triangulate().rotate_y(45)
mesh = tetgen.TetGen(box)
mesh.tetrahedralize(order=1, mindihedral=15, minratio=1.5)
# grid = mesh.grid
# grid.plot(show_edges=True)

# cells = grid.cells.reshape(-1, 5)[:, 1:]
# cell_center = grid.points[cells].mean(1)

# # extract cells below the 0 xy plane
# mask = cell_center[:, 2] < 0
# cell_ind = mask.nonzero()[0]
# subgrid = grid.extract_cells(cell_ind)

# # advanced plotting
# plotter = pv.Plotter()
# plotter.add_mesh(subgrid, 'lightgrey', lighting=True, show_edges=True)
# plotter.add_mesh(sphere, 'r', 'wireframe')
# plotter.add_legend([[' Input Mesh ', 'r'],
#                     [' Tessellated Mesh ', 'black']])
# plotter.show()

ti.init(arch=ti.cpu, debug=True)

# Models
# 'c': Co-rotated linear model
# 'v': St. Venant Kirchhoff model ( StVK )
# 'n': Neo-Hookean model
model = 'c'
prev_model = model
ModelSelector = ti.field(ti.i32, ())
ModelSelector[None] = 0

# physical quantities
# You are encouraged to add sliders for these params!
YoungsModulus = ti.field(ti.f32, ())
PoissonsRatio = ti.field(ti.f32, ())
YoungsModulus[None] = 1e3
PoissonsRatio[None] = 0
gravity = ti.Vector.field(3, dtype=ti.f32, shape=())
gravity[None] = ti.Vector([0, 0, -0.5])
kspring = 100  # This is the stiffness of the user-input spring force!

##############################################################
# TODO: Put additional parameters here
# e.g. Lame parameters
la = ti.field(ti.f32, ())
mu = ti.field(ti.f32, ())
##############################################################

# Load geometry of the simulation scenes
va = mesh.node  # shape: (N_vertices, 3)
# Number of vertices
N = va.shape[0]

# Move the obj to center of the screen
x_avg = np.average(va[:, 0])
y_avg = np.average(va[:, 1])
z_avg = np.average(va[:, 2])
va += np.array([-x_avg, -y_avg, -z_avg])

# Simulation components: x and v
x = ti.Vector.field(3, shape=N, dtype=ti.f32)
# x is initialized directly to the mesh vertices
x.from_numpy(va.astype(np.float32))

tetras = ti.Vector.field(4, shape=mesh.elem.shape[0], dtype=int)
tetras.from_numpy(mesh.elem)  # shape: (n_tets, 4)

# Initialize the bounding box for collision
house = Scene(Init.GB_BOX)

# Number of terahedra
N_tets = tetras.shape[0]
print(mesh.elem.shape)
rest_volumns = ti.field(ti.f32, shape=N_tets)

# We also need to draw the edges
tet_edges = np.array([
    [0, 1], [0, 2], [0, 3],
    [1, 2], [1, 3], [2, 3]
])

edges_set = set()
for i in range(N_tets):
    for e in tet_edges:
        edge = [mesh.elem[i, e[0]], mesh.elem[i, e[1]]]
        edges_set.add(tuple(sorted(edge)))

# Number of edges
N_edges = len(edges_set)
np_edges = np.array([list(e) for e in edges_set])
edges = ti.Vector.field(2, shape=N_edges, dtype=int)
edges.from_numpy(np_edges)

#############################################################
# Deformable object Simulation

# time-step size (for simulation, 16.7ms)
h = 16.7e-3
# substepping
substepping = 100
# time-step size (for time model)
dh = h/substepping

# Mass
m = 1/N*25

v = ti.Vector.field(3, ti.f32, N)

force = ti.Vector.field(2, ti.f32, N)
# spring force generated by user mouse drag
force_idx = ti.field(ti.i32, ())  # vertex being dragged on
# spring force applied to the vertex
spring_force = ti.Vector.field(2, ti.f32, 1)
# forces created by mouse drags in Simulation Mode
force_start_pos = np.array([0, 0])
force_end_pos = np.array([0, 0])
draw_force = False

# Indices pinned by users
pins = ti.field(ti.i32, N)
num_pins = ti.field(ti.i32, ())

# TODO: Put additional fields here for storing D (etc.)
D0 = ti.Matrix.field(3, 3, dtype=ti.f32, shape=N_tets)
D = ti.Matrix.field(3, 3, dtype=ti.f32, shape=N_tets)
F = ti.Matrix.field(3, 3, dtype=ti.f32, shape=N_tets)
stress = ti.Matrix.field(3, 3, dtype=ti.f32, shape=N_tets)


@ti.kernel
def ev2Lame(E: ti.f32, v: ti.f32):
    mu[None] = E / (2 * (1 + v))
    la[None] = E * v / ((1 + v) * (1 - v))


@ti.func
def compute_volumn():
    for i in tetras:
        v0, v1, v2, v3 = tetras[i]
        x0, x1, x2, x3 = x[v0], x[v1], x[v2], x[v3]
        e1 = x1 - x0
        e2 = x2 - x0
        e3 = x3 - x0
        rest_volumns[i] = 1.0 / 6.0 * ti.abs(
            e1.dot(e2.cross(e3)))


@ti.func
def compute_D(D):
    for i in tetras:
        v0, v1, v2, v3 = tetras[i]
        x0, x1, x2, x3 = x[v0], x[v1], x[v2], x[v3]
        D[i] = ti.Matrix.cols([x1-x0, x2-x0, x3-x0])


@ti.func
def compute_F(D, D0):
    for i in tetras:
        F[i] = D[i] @ D0[i].inverse()


@ti.func
def corotated_linear():
    for i in range(N_tets):
        R, S = ti.polar_decompose(F[i])
        strain = S - ti.Matrix.identity(ti.f32, 3)
        stress[i] = R @ (2*mu[None]*strain + la[None] *
                         strain.trace()*ti.Matrix.identity(ti.f32, 2))


@ti.func
def stvk():
    for i in range(N_tets):
        green_strain = 0.5*(F[i].transpose()@F[i] -
                            ti.Matrix.identity(ti.f32, 3))
        stress[i] = F[i] @ (2*mu[None]*green_strain + la[None]
                            * green_strain.trace()*ti.Matrix.identity(ti.f32, 2))


@ti.func
def neo_hookean():
    for i in range(N_tets):
        J = F[i].determinant()
        stress[i] = mu[None] * (F[i] - F[i].inverse().transpose()) + \
            la[None] * ti.log(J) * F[i].inverse().transpose()


@ti.func
def compute_forces():
    if ModelSelector[None] == 0:
        corotated_linear()
    elif ModelSelector[None] == 1:
        stvk()
    else:
        neo_hookean()

    for i in range(N_tets):
        v0, v1, v2, v3 = tetras[i]
        H = -rest_areas[i] * stress[i] @ D0[i].inverse().transpose()
        f1 = H[:, 0]
        f2 = H[:, 1]
        f0 = -f1 - f2
        force[v0] += f0
        force[v1] += f1
        force[v2] += f2


@ti.func
def resolve_collision():
    for b in range(5):
        b1, b2 = house.boundaries[b], house.boundaries[(
            b+1) % house.boundaries.shape[0]]
        p1, p2 = b1.p, b2.p
        wall_vec = p2 - p1
        wall_len = wall_vec.dot(wall_vec)
        for i in range(N):
            to_particle = x[i] - p1
            projection = to_particle.dot(wall_vec)

            t = ti.max(0.0, ti.min(1.0, projection / wall_len))
            closest_point = p1 + t * wall_vec
            distance = (x[i] - closest_point).norm()

            if distance < b1.eps:
                v[i] = v[i] - ti.min(0, v[i].dot(b1.n)) * b1.n


@ti.kernel
def init():
    compute_D(D0)
    compute_volumn()


@ti.kernel
def timestep(currmode: int):
    # TODO: Integrate the internal elastic forces and gravity
    for i in x:
        x[i] += dh*v[i]
        # force[i] = [0, 0]
        force[i] = gravity[None] * m
    compute_D(D)
    compute_F(D, D0)
    compute_forces()

    for i in v:
        v[i] += dh * force[i] / m

    # Add the user-input spring force
    for i in ti.ndrange(num_pins[None]):
        v[pins[i]] = ti.Vector([0, 0])

    # Spring force applied to a single vertex
    cur_spring_len = tm.sqrt(tm.dot(spring_force[0], spring_force[0]))
    if force_idx[None] > 0:
        v[force_idx[None]] += dh*kspring*spring_force[0]/(m)*cur_spring_len

    if currmode == 2:
        resolve_collision()

##############################################################

# GUI


per_vertex_color = ti.Vector.field(3, ti.f32, shape=N)
pin_color = ti.Vector([0, 1, 0])

# For drawing the line indicating force direction/magnitude
draw_force_vertices = ti.Vector.field(2, shape=2, dtype=ti.f32)
draw_force_indices = ti.Vector.field(2, shape=1, dtype=int)
draw_force_indices[0] = ti.Vector([0, 1])

# Parameters for interface
# Mode == 0: Edit
# Mode == 1: Simulate
# Mode == 2: Collision
cur_mode_idx = 0


@ti.kernel
def reset_user_drag():
    force_idx[None] = -1
    spring_force[0] = ti.Vector([0, 0])


def reset_state():
    ModelSelector[None] = 'cvn'.find(model)
    x.from_numpy(va)
    for i in range(N):
        v[i] = ti.Vector([0, 0])
    reset_user_drag()


@ti.kernel
def reset_pins():
    for i in range(num_pins[None]):
        per_vertex_color[pins[i]] = ti.Vector([0, 0, 0])
        pins[i] = 0
    num_pins[None] = 0

####################################################################
# TODO: Run your initialization code
####################################################################


init()
# print("triangles", triangles)
# print("rest_areas", rest_areas)
# print("D0", D0)

paused = True
dm = DistanceMap(N, x)
window = ti.ui.Window("Linear FEM", (600, 600))
scene = ti.ui.Scene()

canvas = window.get_canvas()
canvas.set_background_color((1, 1, 1))
camera = ti.ui.Camera()
camera.projection_mode(ti.ui.ProjectionMode.Perspective)

while window.running:
    camera.position(0, 0, 3)  # x, y, z
    camera.lookat(0, 0, 0)
    camera.up(0, 1, 0)
    scene.set_camera(camera)
    scene.ambient_light((0.8, 0.8, 0.8))
    scene.point_light(pos=(0.5, 1.5, 1.5), color=(1, 1, 1))

    if window.is_pressed(ti.ui.LMB):
        if not draw_force and (cur_mode_idx == 1 or cur_mode_idx == 2):
            draw_force = True
            force_idx[None] = dm.get_closest_vertex(
                ti.Vector(window.get_cursor_pos()))
            if force_idx[None] > 0:
                force_start_pos = np.array([x[force_idx[None]][0],
                                            x[force_idx[None]][1]])
                force_end_pos = force_start_pos
        elif (cur_mode_idx == 1 or cur_mode_idx == 2):
            if force_idx[None] > 0:
                force_start_pos = np.array([x[force_idx[None]][0],
                                            x[force_idx[None]][1]])
                force_end_pos = np.array(window.get_cursor_pos())
                spring_force[0] = ti.Vector(force_end_pos-force_start_pos)
                draw_force_vertices.from_numpy(
                    np.stack((force_start_pos, force_end_pos))
                    .astype(np.float32))
                # canvas.lines(vertices=draw_force_vertices,
                #              indices=draw_force_indices,
                #              color=(1, 0, 0), width=0.002)

    for e in window.get_events(ti.ui.RELEASE):
        if e.key == ti.ui.LMB and (cur_mode_idx == 1 or cur_mode_idx == 2):
            reset_user_drag()
            draw_force = False

    for e in window.get_events(ti.ui.PRESS):
        if e.key in [ti.ui.ESCAPE, ti.GUI.EXIT]:
            exit()
        elif e.key == 'v' or e.key == 'c' or e.key == 'n':
            prev_model = model
            model = e.key
            if prev_model != model:
                reset_state()
        elif e.key == 'm' or e.key == 'M':
            if cur_mode_idx == 2:
                cur_mode_idx = 0
                draw_force = False
                reset_state()
            else:
                cur_mode_idx = (cur_mode_idx + 1) % 2
        elif e.key == 't' or e.key == 'T':
            if cur_mode_idx == 2:
                cur_mode_idx = 0
                reset_state()
                draw_force = False
            else:
                cur_mode_idx = 2
                reset_pins()
                reset_state()
                draw_force = False
        elif e.key == ti.GUI.LMB and cur_mode_idx == 0:
            vertex_idx = dm.get_closest_vertex(
                ti.Vector(window.get_cursor_pos()))
            is_pinned = False
            pin_idx = -1
            if vertex_idx >= 0:
                for i in range(num_pins[None]):
                    if pins[i] == vertex_idx:
                        is_pinned = True
                        pin_idx = i
                        break
                if not is_pinned:
                    pins[num_pins[None]] = vertex_idx
                    num_pins[None] += 1
                    per_vertex_color[vertex_idx] = pin_color
                else:
                    for i in range(pin_idx, num_pins[None]-1):
                        pins[i] = pins[i+1]
                    num_pins[None] -= 1
                    per_vertex_color[vertex_idx] = ti.Vector([0, 0, 0])

        elif e.key == 'r' or e.key == 'R':
            if cur_mode_idx == 0:
                reset_pins()
            else:
                reset_state()

        elif e.key == ti.GUI.SPACE:
            paused = not paused

    ##############################################################
    # if not paused:
    #     # TODO: run all of your simulation code here
    #     ev2Lame(YoungsModulus[None], PoissonsRatio[None])
    #     for i in range(substepping):
    #         timestep(cur_mode_idx)
    ##############################################################

    scene.particles(x, per_vertex_color=per_vertex_color, radius=0.01)
    scene.lines(x, indices=edges, width=0.002,
                color=(0, 0, 0))

    # # Draw the gingerbread house if we switch to collision testing mode
    # if cur_mode_idx == 2:
    #     canvas.lines(house.boundaries.p, width=0.01,
    #                  indices=house.boundary_indices, color=(0.4, 0.2, 0.0))

    # text
    gui = window.get_gui()
    with gui.sub_window("Controls", 0.02, 0.02, 0.4, 0.25) as w:
        if model == 'c':
            gui.text('Co-rotated linear model')
        elif model == 'v':
            gui.text('Venant-Kirchhoff model')
        else:
            gui.text('Neo-Hookean model')

        YoungsModulus[None] = w.slider_float(
            "Young's Modulus", YoungsModulus[None], minimum=1e2, maximum=1e5)
        PoissonsRatio[None] = w.slider_float(
            "Possion's Ratio", PoissonsRatio[None], minimum=0, maximum=0.5)
        gravity[None][1] = w.slider_float(
            "Gravity", gravity[None][1], minimum=0, maximum=-9.8)

        if cur_mode_idx == 0:
            gui.text('Edit mode: Click to pin/unpin vertices')
        elif cur_mode_idx == 1:
            gui.text('Simulation mode: Drag to create forces')
        else:
            gui.text('Collision mode: Drag to move the deformable')

        gui.text('Press \'c,v,n\' to switch model')
        gui.text('Press \'m\' to switch mode')
        gui.text('Press \'t\' to switch between two simulation scenes')
        gui.text('Press \'r\' to: ')
        gui.text('* Clear all pinned points (edit mode)')
        gui.text('* Reset to initial state (simulation mode)')
        gui.text('Press \'SPACE\' to pause/unpause')

        if paused:
            gui.text('Simulation PAUSED')

    canvas.scene(scene)
    window.show()
